* Motivation

  I made the decision tree compiler for other reasons and realized
  that it would make experimenting with the dispatch technique and
  bechmarking it more comprehensively pretty easy.

  The other motivation is making the benchmark more realistic and
  somewhat fairer:

  + Put the discriminating function into a funcallable instance in
    case that introduces additional function call overhead.

  + Type-check the argument instead of unsafely extracting the stamp
    (afaict, e.g. fixnums will not have a rack so that test will be
    needed).

  + Generate an actual decision tree. The simulated dispatch function
    in the paper

    #+BEGIN_SRC lisp
      (defun yy (instance)
        (declare (optimize (safety 0) (speed 3) (debug 0)))
        (let* ((rack (s-rack instance))
               (stamp (svref rack 0)))
          (declare (type fixnum stamp))
          (cond ((> stamp 1280) (error "1"))
                ((> stamp 640) (error "2"))
                ((> stamp 320) (error "3"))
                ((> stamp 160) (error "4"))
                ((> stamp 80) (error "5"))
                ((> stamp 40) (error "6"))
                ((> stamp 20) (error "7"))
                ((> stamp 10) (error "8"))
                (t (svref rack 1)))))
    #+END_SRC

    compiles to tests which "fall through" in the alternative
    case. This executes much faster than a real decision tree.

  + Exploit SBCL's new immobile space: SBCL's equivalent of "general
    instances" with class and "rack" pointers in the paper are
    "instances" and "layouts". The latter are placed in immobile space
    where the gc does not move them. The idea is to use layout
    addresses where "stamps" are used in the paper.

* Code

  We will define two kinds of generic-function-like things (in the
  sense that the instances will be ~funcallable-standard-object~ s and
  their instance functions will do generic-function-like dispatch):

  + ~typep-gf~ :: This uses a ~typep~-based decision procedure and
                  serves as a baseline (in addition to SBCL's actual
                  generic function implementation). It is also used
                  for implementing ~layout-gf~ without going through
                  the actual
                  ~compute-applicable-methods-using-classes~
                  shenanigans.

  + ~layout-gf~ :: This is the interesting one. Its dispatch function
                   works by extracting the layout of the generic
                   function argument and taking its address. This
                   address is used in a decision procedure based on
                   the call history. This is mostly a more
                   fleshed-out, SBCL-adapted version of the generic
                   function dispatch presented in the paper.

** Decision Tree Compiler

   Since it will be used in both implementations here is a brief
   demonstration of the decision tree compiler (full code in
   [[file:decision-tree.lisp]], [[file:interval-decision-procedure.lisp]] and
   [[file:typep-decision-procedure.lisp]]):

   + For intervals ::

     #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
       (defparameter *interval-tree*
         (let ((interface (make-instance 'interval-dispatch :number-var 'number)))
           (make-decision-tree interface '((1 . 5) (0 . 10) (7 . 7) (8 . *))
                               :previous-tests '((< 0 nil)))))

       (print-decision-tree *interval-tree*)
     #+END_SRC

     #+RESULTS:
     #+begin_example
     (< 8 T)
     ├─(< 7 T)
     │ ├─(< 6 T)
     │ │ ├─(< 1 T)
     │ │ │ ├─{(0 . 10)}
     │ │ │ └─{(0 . 10) (1 . 5)}
     │ │ └─{(0 . 10)}
     │ └─{(0 . 10) (7 . 7)}
     └─(< 11 T)
       ├─{(8 . *) (0 . 10)}
       └─{(8 . *)}
     #+end_example

     #+BEGIN_SRC lisp :exports both :results value scalar code :package dispatch-experiment
       (emit-decision-tree-code
        ,*interval-tree* (lambda (candidates info)
                          `'(:candidates ,candidates :info ,info)))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC lisp

     (IF (< NUMBER 8)
         (IF (< NUMBER 7)
             (IF (< NUMBER 6)
                 (IF (< NUMBER 1)
                     '(:CANDIDATES ((0 . 10)) :INFO ((0 0 NIL)))
                     '(:CANDIDATES ((0 . 10) (1 . 5)) :INFO ((1 5 NIL))))
                 '(:CANDIDATES ((0 . 10)) :INFO ((6 6 NIL))))
             '(:CANDIDATES ((0 . 10) (7 . 7)) :INFO ((7 7 NIL))))
         (IF (< NUMBER 11)
             '(:CANDIDATES ((8 . *) (0 . 10)) :INFO ((8 10 NIL)))
             '(:CANDIDATES ((8 . *)) :INFO ((11 4611686018427387903 NIL)))))
     #+END_SRC

   + For types ::

     #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
       (defparameter *type-tree*
         (let ((interface (make-instance 'type-discrimination :object-var 'object)))
           (make-decision-tree interface '(integer number single-float string class))))

         (print-decision-tree *type-tree*)
     #+END_SRC

     #+RESULTS:
     #+begin_example
     (NUMBER T)
     ├─(INTEGER T)
     │ ├─{NUMBER INTEGER}
     │ └─(SINGLE-FLOAT T)
     │   ├─{NUMBER SINGLE-FLOAT}
     │   └─{NUMBER}
     └─(STRING T)
       ├─{STRING}
       └─(CLASS T)
         ├─{CLASS}
         └─{}
     #+end_example

     #+BEGIN_SRC lisp :exports both :results value scalar code :package dispatch-experiment
       (emit-decision-tree-code *type-tree* (lambda (candidates info)
                                                  `'(:candidates ,candidates :info ,info)))
     #+END_SRC

     #+RESULTS:
     #+BEGIN_SRC lisp

     (IF (TYPEP OBJECT 'NUMBER)
         (IF (TYPEP OBJECT 'INTEGER)
             '(:CANDIDATES (NUMBER INTEGER) :INFO ((AND INTEGER NUMBER)))
             (IF (TYPEP OBJECT 'SINGLE-FLOAT)
                 '(:CANDIDATES (NUMBER SINGLE-FLOAT) :INFO
                   ((AND SINGLE-FLOAT (NOT INTEGER) NUMBER)))
                 '(:CANDIDATES (NUMBER) :INFO
                   ((AND (NOT SINGLE-FLOAT) (NOT INTEGER) NUMBER)))))
         (IF (TYPEP OBJECT 'STRING)
             '(:CANDIDATES (STRING) :INFO ((AND STRING (NOT NUMBER))))
             (IF (TYPEP OBJECT 'CLASS)
                 '(:CANDIDATES (CLASS) :INFO
                   ((AND CLASS (NOT STRING) (NOT NUMBER))))
                 '(:CANDIDATES NIL :INFO
                   ((AND (NOT CLASS) (NOT STRING) (NOT NUMBER)))))))
     #+END_SRC

** ~typep-gf~

   #+BEGIN_SRC lisp
     (cl:in-package #:dispatch-experiment)

     ;;; `typep'-based discriminating function

     (defun make-typep-discriminator-form (types)
       (let* ((object-var 'object)
              (interface  (make-instance 'type-discrimination :object-var object-var))
              (tree       (make-decision-tree interface types)))
         `(lambda (,object-var)
            (declare (optimize (speed 3) (debug 0) (safety 0)))
            ,(emit-decision-tree-code
              tree (lambda (candidates info)
                     (declare (ignore info))
                     `',candidates)))))

     (defun make-typep-discriminator (types)
       (compile nil (make-typep-discriminator-form types)))

     ;;; Generic function

     (defclass typep-gf (sb-mop:funcallable-standard-object)
       ((discriminator :accessor discriminator))
       (:metaclass sb-mop:funcallable-standard-class))

     (defmethod shared-initialize :after ((instance   typep-gf)
                                          (slot-names t)
                                          &key
                                            classes)
       (sb-mop:set-funcallable-instance-function
        instance (make-typep-discriminator classes)))
   #+END_SRC

** ~layout-gf~

   #+BEGIN_SRC lisp
     (cl:in-package #:dispatch-experiment)

     ;;; Layout discrimination

     (defun make-discriminating-function-form (layouts->outcomes miss-form &key assume-instance-p)
       (let* ((layout-addresses (map 'list (lambda+ ((layout . &ign))
                                             (sb-vm::get-lisp-obj-address layout))
                                     layouts->outcomes))
              (interface        (make-instance 'interval-dispatch :number-var 'address))
              (tree             (make-decision-tree interface (map 'list (lambda (address)
                                                                           (cons address address))
                                                                   layout-addresses))))
         (format t "Assuming argument is an instance: ~S~%" assume-instance-p)
         `(lambda (object)
            (declare (optimize (speed 3) (debug 0) (safety 0)))
            (let ((address (sb-vm::get-lisp-obj-address ,(if assume-instance-p
                                                             `(sb-kernel:%instance-layout object)
                                                             `(sb-kernel:layout-of object)))))
              ,(emit-decision-tree-code
                tree
                (lambda (candidates info)
                  (declare (ignore info))
                  (if candidates
                      `',(map 'list (lambda (address)
                                      (cdr (elt layouts->outcomes (position (car address) layout-addresses))))
                              candidates)
                      miss-form)))))))

     (defun make-discriminating-function (layouts->outcomes miss-form &key assume-instance-p)
       (compile nil (make-discriminating-function-form
                     layouts->outcomes miss-form
                     :assume-instance-p assume-instance-p)))

     ;; Generic function

     (defclass layout-gf (sb-mop:funcallable-standard-object)
       ((classes       :initarg  :classes
                       :accessor classes)
        (call-history  :accessor call-history
                       :initform '())
        (discriminator :accessor discriminator))
       (:metaclass sb-mop:funcallable-standard-class))

     (defun cache-miss (generic-function object)
       (let ((class (funcall (discriminator generic-function) object)))
         (push (cons (sb-kernel:layout-of object) class)
               (call-history generic-function)))
       (sb-mop:set-funcallable-instance-function
        generic-function
        (make-discriminating-function
         (call-history generic-function)
         `(cache-miss ,generic-function object)
         :assume-instance-p (every (lambda+ ((&ign . classes))
                                     (every (rcurry #'subtypep 'standard-object)
                                            classes))
                                   (call-history generic-function))))
       (funcall generic-function object))

     (defmethod shared-initialize :after ((instance   layout-gf)
                                          (slot-names t)
                                          &key
                                            classes)
       (setf (discriminator instance) (make-typep-discriminator classes))
       (sb-mop:set-funcallable-instance-function
        instance (lambda (object)
                   (cache-miss instance object))))
   #+END_SRC

* Results

** Benchmark for General Lisp Objects

   #+BEGIN_SRC lisp
     (cl:in-package #:dispatch-experiment)

     (defgeneric standard-gf (object)
       (:method ((object number))
         :number)
       (:method ((object double-float))
         :double-float)
       (:method ((object integer))
         :integer)
       (:method ((object symbol))
         :symbol)
       (:method ((object cons))
         :cons)
       (:method ((object list))
         :list)
       (:method ((object null))
         :null)
       (:method ((object class))
         :class)
       (:method ((object standard-object))
         :standard-object))

     (defparameter *generic-classes*
       '(number double-float integer symbol cons list null class standard-object))

     (defun prepare-generic-typep-vs-layout-address-vs-standard-gf ()
       (let+ ((layout-gf (make-instance 'layout-gf :classes *generic-classes*))
              (typep-gf  (make-instance 'typep-gf  :classes *generic-classes*))
              ((&flet call (gf object)
                 (funcall gf object)
                 (funcall gf object)))
              ((&flet calls (gf)
                 (call gf 1)
                 (call gf 1.0d0)
                 (call gf 1.0f0)
                 (call gf (1+ most-positive-fixnum))
                 (call gf :foo)
                 (call gf nil)
                 (call gf (cons 1 2))
                 (call gf (find-class 'class))
                 (call gf #'standard-gf))))
         ;; Populate call history
         (calls layout-gf)
         (calls typep-gf)
         (calls #'standard-gf)

         (values layout-gf typep-gf)))

     (defun run-generic-typep-vs-layout-address-vs-standard-gf (layout-gf typep-gf)
       (let+ (((&flet bench (gf object)
                 (declare (type function gf))
                 ;; Warm up
                 (loop :repeat 100 :do (funcall gf object))
                 ;; Time it
                 (let ((*trace-output* *standard-output*))
                   (time (locally (declare (optimize (speed 3) (debug 0) (safety 0)))
                           (loop :repeat 100000000 :do (funcall gf object))))))))
         ;; Benchmark runs
         (format t "object 1~%")
         (bench layout-gf     1)
         (bench typep-gf      1)
         (bench #'standard-gf 1)

         (format t "object nil~%")
         (bench layout-gf     nil)
         (bench typep-gf      nil)
         (bench #'standard-gf nil)

         (format t "object (1 . 2)~%")
         (bench layout-gf     '(1 . 2))
         (bench typep-gf      '(1 . 2))
         (bench #'standard-gf '(1 . 2))))

   #+END_SRC

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (defparameter *generic-layout-gf* nil)
     (defparameter *generic-typep-gf* nil)
     (setf (values *generic-layout-gf* *generic-typep-gf*)
           (prepare-generic-typep-vs-layout-address-vs-standard-gf))
   #+END_SRC

   #+RESULTS:
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL
   : Assuming argument is an instance: NIL

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (let* ((layout-addresses (map 'list (lambda+ ((layout . &ign))
                                           (sb-vm::get-lisp-obj-address layout))
                                   (call-history *generic-layout-gf*)))
            (interface        (make-instance 'interval-dispatch :number-var 'address))
            (tree             (make-decision-tree interface (map 'list (lambda (address)
                                                                         (cons address address))
                                                                 layout-addresses))))

       (format t "Layout addresses:~%~{~2@T~{~D~%~4@T~A~%~4@T~A~}~%~}"
               (map 'list (lambda+ ((layout . classes))
                            (list (sb-vm::get-lisp-obj-address layout) layout classes))
                    (call-history *generic-layout-gf*)))
       (print-decision-tree tree))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   Layout addresses:
     540670723
       #<LAYOUT for STANDARD-GENERIC-FUNCTION {2039FB03}>
       (STANDARD-OBJECT)
     540725507
       #<LAYOUT for STANDARD-CLASS {203AD103}>
       (STANDARD-OBJECT CLASS)
     540599811
       #<LAYOUT for CONS {2038E603}>
       (CONS LIST)
     540097027
       #<LAYOUT for NULL {20313A03}>
       (SYMBOL LIST NULL)
     540096771
       #<LAYOUT for SYMBOL {20313903}>
       (SYMBOL)
     540590851
       #<LAYOUT for BIGNUM {2038C303}>
       (NUMBER INTEGER)
     540581123
       #<LAYOUT for SINGLE-FLOAT {20389D03}>
       (NUMBER)
     540581379
       #<LAYOUT for DOUBLE-FLOAT {20389E03}>
       (NUMBER DOUBLE-FLOAT)
     540590595
       #<LAYOUT for FIXNUM {2038C203}>
       (NUMBER INTEGER)
   (< 540590596 T)
   ├─(< 540581379 T)
   │ ├─(= 540581123 T)
   │ │ ├─{(540581123 . 540581123)}
   │ │ └─(= 540096771 T)
   │ │   ├─{(540096771 . 540096771)}
   │ │   └─(= 540097027 T)
   │ │     ├─{(540097027 . 540097027)}
   │ │     └─{}
   │ └─(< 540590595 T)
   │   ├─(< 540581380 T)
   │   │ ├─{(540581379 . 540581379)}
   │   │ └─{}
   │   └─{(540590595 . 540590595)}
   └─(< 540599812 T)
     ├─(< 540599811 T)
     │ ├─(= 540590851 T)
     │ │ ├─{(540590851 . 540590851)}
     │ │ └─{}
     │ └─{(540599811 . 540599811)}
     └─(= 540725507 T)
       ├─{(540725507 . 540725507)}
       └─(= 540670723 T)
         ├─{(540670723 . 540670723)}
         └─{}
   #+end_example

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (sb-disassem:disassemble-code-component
       (sb-kernel:funcallable-instance-fun *generic-layout-gf*))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   ; Size: 528 bytes. Origin: #x1007FB5260 (segment 1 of 2)
   ; 260:       .ENTRY (LAMBDA (OBJECT))()                       ; FUNCTION
   ; 290:       8F4508           POP QWORD PTR [RBP+8]
   ; 293:       488D65F8         LEA RSP, [RBP-8]
   ; 297:       488BCA           MOV RCX, RDX
   ; Origin #x1007FB529A (segment 2 of 2)
   ; 29A:       8D41FD           LEA EAX, [RCX-3]                ; no-arg-parsing entry point
   ; 29D:       A80F             TEST AL, 15
   ; 29F:       0F84C3010000     JEQ L20
   ; 2A5:       8D41F5           LEA EAX, [RCX-11]
   ; 2A8:       A80F             TEST AL, 15
   ; 2AA:       750A             JNE L0
   ; 2AC:       8079F539         CMP BYTE PTR [RCX-11], 57
   ; 2B0:       0F84AA010000     JEQ L19
   ; 2B6: L0:   4881F917001020   CMP RCX, 537919511
   ; 2BD:       0F8565010000     JNE L15
   ; 2C3:       488B150EFFFFFF   MOV RDX, [RIP-242]              ; #<SB-KERNEL:LAYOUT for NULL {20313A03}>
   ; 2CA: L1:   4881FA04C23820   CMP RDX, 540590596
   ; 2D1:       0F83B5000000     JNB L9
   ; 2D7:       488D1C12         LEA RBX, [RDX+RDX]
   ; 2DB:       4881FB063C7140   CMP RBX, 1081162758
   ; 2E2:       7C4B             JL L5
   ; 2E4:       488D1C12         LEA RBX, [RDX+RDX]
   ; 2E8:       4881FB06847140   CMP RBX, 1081181190
   ; 2EF:       7C0D             JL L3
   ; 2F1:       488B15E8FEFFFF   MOV RDX, [RIP-280]              ; '((NUMBER
                                                                 ;    INTEGER))
   ; 2F8: L2:   488BE5           MOV RSP, RBP
   ; 2FB:       F8               CLC
   ; 2FC:       5D               POP RBP
   ; 2FD:       C3               RET
   ; 2FE: L3:   48D1E2           SHL RDX, 1
   ; 301:       4881FA083C7140   CMP RDX, 1081162760
   ; 308:       7D09             JNL L4
   ; 30A:       488B15D7FEFFFF   MOV RDX, [RIP-297]              ; '((NUMBER
                                                                 ;    DOUBLE-FLOAT))
   ; 311:       EBE5             JMP L2
   ; 313: L4:   488B15D6FEFFFF   MOV RDX, [RIP-298]              ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100785FD3B}>
   ; 31A:       488BF9           MOV RDI, RCX
   ; 31D:       488B05D4FEFFFF   MOV RAX, [RIP-300]              ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 324:       B904000000       MOV ECX, 4
   ; 329:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 32C:       FF6009           JMP QWORD PTR [RAX+9]
   ; 32F: L5:   488D1C12         LEA RBX, [RDX+RDX]
   ; 333:       4881FB063A7140   CMP RBX, 1081162246
   ; 33A:       7509             JNE L6
   ; 33C:       488B15BDFEFFFF   MOV RDX, [RIP-323]              ; '((NUMBER))
   ; 343:       EBB3             JMP L2
   ; 345: L6:   488D1C12         LEA RBX, [RDX+RDX]
   ; 349:       4881FB06726240   CMP RBX, 1080193542
   ; 350:       7509             JNE L7
   ; 352:       488B15AFFEFFFF   MOV RDX, [RIP-337]              ; '((SYMBOL))
   ; 359:       EB9D             JMP L2
   ; 35B: L7:   48D1E2           SHL RDX, 1
   ; 35E:       4881FA06746240   CMP RDX, 1080194054
   ; 365:       7509             JNE L8
   ; 367:       488B15A2FEFFFF   MOV RDX, [RIP-350]              ; '((SYMBOL LIST
                                                                 ;    NULL))
   ; 36E:       EB88             JMP L2
   ; 370: L8:   488B15A1FEFFFF   MOV RDX, [RIP-351]              ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100785FD3B}>
   ; 377:       488BF9           MOV RDI, RCX
   ; 37A:       488B0577FEFFFF   MOV RAX, [RIP-393]              ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 381:       B904000000       MOV ECX, 4
   ; 386:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 389:       FF6009           JMP QWORD PTR [RAX+9]
   ; 38C: L9:   4881FA04E63820   CMP RDX, 540599812
   ; 393:       7246             JB L12
   ; 395:       4881FA03D13A20   CMP RDX, 540725507
   ; 39C:       750C             JNE L10
   ; 39E:       488B157BFEFFFF   MOV RDX, [RIP-389]              ; '((STANDARD-OBJECT
                                                                 ;    CLASS))
   ; 3A5:       E94EFFFFFF       JMP L2
   ; 3AA: L10:  4881FA03FB3920   CMP RDX, 540670723
   ; 3B1:       750C             JNE L11
   ; 3B3:       488B156EFEFFFF   MOV RDX, [RIP-402]              ; '((STANDARD-OBJECT))
   ; 3BA:       E939FFFFFF       JMP L2
   ; 3BF: L11:  488B156AFEFFFF   MOV RDX, [RIP-406]              ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100785FD3B}>
   ; 3C6:       488BF9           MOV RDI, RCX
   ; 3C9:       488B0528FEFFFF   MOV RAX, [RIP-472]              ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 3D0:       B904000000       MOV ECX, 4
   ; 3D5:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 3D8:       FF6009           JMP QWORD PTR [RAX+9]
   ; 3DB: L12:  488D1C12         LEA RBX, [RDX+RDX]
   ; 3DF:       4881FB06CC7140   CMP RBX, 1081199622
   ; 3E6:       7C0C             JL L13
   ; 3E8:       488B1549FEFFFF   MOV RDX, [RIP-439]              ; '((CONS LIST))
   ; 3EF:       E904FFFFFF       JMP L2
   ; 3F4: L13:  48D1E2           SHL RDX, 1
   ; 3F7:       4881FA06867140   CMP RDX, 1081181702
   ; 3FE:       750C             JNE L14
   ; 400:       488B1539FEFFFF   MOV RDX, [RIP-455]              ; '((NUMBER
                                                                 ;    INTEGER))
   ; 407:       E9ECFEFFFF       JMP L2
   ; 40C: L14:  488B1535FEFFFF   MOV RDX, [RIP-459]              ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100785FD3B}>
   ; 413:       488BF9           MOV RDI, RCX
   ; 416:       488B05DBFDFFFF   MOV RAX, [RIP-549]              ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 41D:       B904000000       MOV ECX, 4
   ; 422:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 425:       FF6009           JMP QWORD PTR [RAX+9]
   ; 428: L15:  0FB6C1           MOVZX EAX, CL
   ; 42B:       240F             AND AL, 15
   ; 42D:       3C0F             CMP AL, 15
   ; 42F:       7417             JEQ L17
   ; 431:       3C0B             CMP AL, 11
   ; 433:       740D             JEQ L16
   ; 435:       A801             TEST AL, 1
   ; 437:       7413             JEQ L18
   ; 439:       A802             TEST AL, 2
   ; 43B:       750F             JNE L18
   ; 43D:       0FB6C1           MOVZX EAX, CL
   ; 440:       EB0A             JMP L18
   ; 442: L16:  0FB641F5         MOVZX EAX, BYTE PTR [RCX-11]
   ; 446:       EB04             JMP L18
   ; 448: L17:  0FB641F1         MOVZX EAX, BYTE PTR [RCX-15]
   ; 44C: L18:  48D1E0           SHL RAX, 1
   ; 44F:       488B15FAFDFFFF   MOV RDX, [RIP-518]              ; #(#<SB-KERNEL:LAYOUT for FIXNUM {2038C203}>
                                                                 ;   #<SB-KERNEL:LAYOUT for SB-KERNEL::RANDOM-CLASS {20389503}> ..)
   ; 456:       488B548201       MOV RDX, [RDX+RAX*4+1]
   ; 45B:       E96AFEFFFF       JMP L1
   ; 460: L19:  8B51F9           MOV EDX, [RCX-7]
   ; 463:       E962FEFFFF       JMP L1
   ; 468: L20:  8B5101           MOV EDX, [RCX+1]
   ; 46B:       E95AFEFFFF       JMP L1
   #+end_example

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (run-generic-typep-vs-layout-address-vs-standard-gf
      *generic-layout-gf* *generic-typep-gf*)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   object 1
   Evaluation took:
     0.568 seconds of real time
     0.567223 seconds of total run time (0.567197 user, 0.000026 system)
     99.82% CPU
     1,698,347,484 processor cycles
     0 bytes consed

   Evaluation took:
     0.423 seconds of real time
     0.423581 seconds of total run time (0.423556 user, 0.000025 system)
     100.24% CPU
     1,267,757,316 processor cycles
     0 bytes consed

   Evaluation took:
     0.596 seconds of real time
     0.596865 seconds of total run time (0.596765 user, 0.000100 system)
     100.17% CPU
     1,786,313,655 processor cycles
     0 bytes consed

   object nil
   Evaluation took:
     0.802 seconds of real time
     0.743110 seconds of total run time (0.739438 user, 0.003672 system)
     92.64% CPU
     2,397,590,715 processor cycles
     0 bytes consed

   Evaluation took:
     0.918 seconds of real time
     0.916761 seconds of total run time (0.912808 user, 0.003953 system)
     99.89% CPU
     2,748,152,046 processor cycles
     0 bytes consed

   Evaluation took:
     0.522 seconds of real time
     0.522147 seconds of total run time (0.522147 user, 0.000000 system)
     100.00% CPU
     1,562,629,530 processor cycles
     0 bytes consed

   object (1 . 2)
   Evaluation took:
     0.692 seconds of real time
     0.690659 seconds of total run time (0.690659 user, 0.000000 system)
     99.86% CPU
     2,069,846,151 processor cycles
     0 bytes consed

   Evaluation took:
     0.686 seconds of real time
     0.686639 seconds of total run time (0.686464 user, 0.000175 system)
     100.15% CPU
     2,054,913,891 processor cycles
     0 bytes consed

   Evaluation took:
     0.622 seconds of real time
     0.621589 seconds of total run time (0.621589 user, 0.000000 system)
     100.00% CPU
     1,860,226,368 processor cycles
     0 bytes consed

   #+end_example

** Benchmark for ~standard-object~ instances

   As shown above, the significance of this benchmark lies in the fact
   that the ~layout-gf~ can assume the argument is an instance when
   extracting the layout.

   #+BEGIN_SRC lisp
     (cl:in-package #:dispatch-experiment)

     (progn
       (defclass a1 () ()) (defclass b1 () ()) (defclass c1 () ()) (defclass d1 () ())
       (defclass a2 () ()) (defclass b2 () ()) (defclass c2 () ()) (defclass d2 () ())
       (defclass a3 () ()) (defclass b3 () ()) (defclass c3 () ()) (defclass d3 () ()))

     (defgeneric standard-gf2 (object)
       (:method ((object a1))
         :a1)
       (:method ((object b1))
         :b1)
       (:method ((object c1))
         :c1)
       (:method ((object d1))
         :d1)
       (:method ((object a2))
         :a2)
       (:method ((object b2))
         :b2)
       (:method ((object c2))
         :c2)
       (:method ((object d2))
         :d2)
       (:method ((object a3))
         :a3)
       (:method ((object b3))
         :b3)
       (:method ((object c3))
         :c3)
       (:method ((object d3))
         :d3))

     (defparameter *standard-object-classes*
       '(a1 b1 c1 d1 a2 b2 c2 d2 a3 b3 c3 d3))

     (defun prepare-standard-object-layout-address-vs-standard-gf ()
       (let+ ((layout-gf (make-instance 'layout-gf :classes *standard-object-classes*))
              ;; (typep-gf  (make-instance 'typep-gf  :classes *standard-object-classes*))
              ((&flet calls (gf)
                 (map nil (compose (curry #'funcall gf) #'make-instance)
                      ,*standard-object-classes*))))
         (calls layout-gf)
         ;; (calls typep-gf)
         (calls #'standard-gf2)

         layout-gf))

     (defun run-standard-object-layout-address-vs-standard-gf (layout-gf #+no typep-gf)
       (let+ (((&flet bench (gf object)
                 (declare (type sb-mop:funcallable-standard-object gf))
                 ;; Warm up
                 (loop :repeat 100 :do (funcall gf object))
                 ;; Time it
                 (let ((*trace-output* *standard-output*))
                   (time (locally (declare (optimize (speed 3) (debug 0) (safety 0)))
                           (loop :repeat 1000000000 :do (funcall gf object))))))))
         (let ((object (make-instance 'd2)))
           (format t "object ~%")
           (bench layout-gf     object)
           ;; (bench typep-gf      object)
           (bench #'standard-gf object))))
   #+END_SRC

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (defparameter *standard-object-layout-gf*
       (prepare-standard-object-layout-address-vs-standard-gf *standard-object-classes*))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   Assuming argument is an instance: T
   #+end_example

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (let* ((layout-addresses (map 'list (lambda+ ((layout . &ign))
                                           (sb-vm::get-lisp-obj-address layout))
                                   (call-history *standard-object-layout-gf*)))
            (interface        (make-instance 'interval-dispatch :number-var 'address))
            (tree             (make-decision-tree interface (map 'list (lambda (address)
                                                                         (cons address address))
                                                                 layout-addresses))))

       (format t "Layout addresses:~%~{~2@T~{~D~%~4@T~A~%~4@T~A~}~%~}"
               (map 'list (lambda+ ((layout . classes))
                            (list (sb-vm::get-lisp-obj-address layout) layout classes))
                    (call-history *standard-object-layout-gf*)))
       (print-decision-tree tree))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   Layout addresses:
     541485827
       #<LAYOUT for D3 {20466B03}>
       (D3)
     541485571
       #<LAYOUT for C3 {20466A03}>
       (C3)
     541485315
       #<LAYOUT for B3 {20466903}>
       (B3)
     541485059
       #<LAYOUT for A3 {20466803}>
       (A3)
     541484803
       #<LAYOUT for D2 {20466703}>
       (D2)
     541484547
       #<LAYOUT for C2 {20466603}>
       (C2)
     541484291
       #<LAYOUT for B2 {20466503}>
       (B2)
     541484035
       #<LAYOUT for A2 {20466403}>
       (A2)
     541483779
       #<LAYOUT for D1 {20466303}>
       (D1)
     541483523
       #<LAYOUT for C1 {20466203}>
       (C1)
     541483267
       #<LAYOUT for B1 {20466103}>
       (B1)
     541483011
       #<LAYOUT for A1 {20466003}>
       (A1)
   (< 541484292 T)
   ├─(< 541483524 T)
   │ ├─(< 541483523 T)
   │ │ ├─(= 541483011 T)
   │ │ │ ├─{(541483011 . 541483011)}
   │ │ │ └─(= 541483267 T)
   │ │ │   ├─{(541483267 . 541483267)}
   │ │ │   └─{}
   │ │ └─{(541483523 . 541483523)}
   │ └─(< 541484291 T)
   │   ├─(= 541483779 T)
   │   │ ├─{(541483779 . 541483779)}
   │   │ └─(= 541484035 T)
   │   │   ├─{(541484035 . 541484035)}
   │   │   └─{}
   │   └─{(541484291 . 541484291)}
   └─(< 541485060 T)
     ├─(< 541485059 T)
     │ ├─(= 541484547 T)
     │ │ ├─{(541484547 . 541484547)}
     │ │ └─(= 541484803 T)
     │ │   ├─{(541484803 . 541484803)}
     │ │   └─{}
     │ └─{(541485059 . 541485059)}
     └─(= 541485315 T)
       ├─{(541485315 . 541485315)}
       └─(= 541485571 T)
         ├─{(541485571 . 541485571)}
         └─(= 541485827 T)
           ├─{(541485827 . 541485827)}
           └─{}
   #+end_example

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (sb-disassem:disassemble-code-component
       (sb-kernel:funcallable-instance-fun *standard-object-layout-gf*))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   ; Size: 477 bytes. Origin: #x1002DC5EA0 (segment 1 of 2)
   ; 5EA0:       .ENTRY (LAMBDA (OBJECT))()                      ; FUNCTION
   ; 5ED0:       8F4508           POP QWORD PTR [RBP+8]
   ; 5ED3:       488D65F8         LEA RSP, [RBP-8]
   ; 5ED7:       488BCA           MOV RCX, RDX
   ; Origin #x1002DC5EDA (segment 2 of 2)
   ; 5EDA:       8B4101           MOV EAX, [RCX+1]               ; no-arg-parsing entry point
   ; 5EDD:       483D04654620     CMP RAX, 541484292
   ; 5EE3:       0F83CF000000     JNB L8
   ; 5EE9:       488D1400         LEA RDX, [RAX+RAX]
   ; 5EED:       4881FA08C48C40   CMP RDX, 1082967048
   ; 5EF4:       7C63             JL L4
   ; 5EF6:       488D1400         LEA RDX, [RAX+RAX]
   ; 5EFA:       4881FA06CA8C40   CMP RDX, 1082968582
   ; 5F01:       7C10             JL L1
   ; 5F03:       488B0D0EFFFFFF   MOV RCX, [RIP-242]             ; '((B2))
   ; 5F0A: L0:   488BD1           MOV RDX, RCX
   ; 5F0D:       488BE5           MOV RSP, RBP
   ; 5F10:       F8               CLC
   ; 5F11:       5D               POP RBP
   ; 5F12:       C3               RET
   ; 5F13: L1:   488D1400         LEA RDX, [RAX+RAX]
   ; 5F17:       4881FA06C68C40   CMP RDX, 1082967558
   ; 5F1E:       7509             JNE L2
   ; 5F20:       488B0DF9FEFFFF   MOV RCX, [RIP-263]             ; '((D1))
   ; 5F27:       EBE1             JMP L0
   ; 5F29: L2:   48D1E0           SHL RAX, 1
   ; 5F2C:       483D06C88C40     CMP RAX, 1082968070
   ; 5F32:       7509             JNE L3
   ; 5F34:       488B0DEDFEFFFF   MOV RCX, [RIP-275]             ; '((A2))
   ; 5F3B:       EBCD             JMP L0
   ; 5F3D: L3:   488B15ECFEFFFF   MOV RDX, [RIP-276]             ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100837B74B}>
   ; 5F44:       488BF9           MOV RDI, RCX
   ; 5F47:       488B05EAFEFFFF   MOV RAX, [RIP-278]             ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 5F4E:       B904000000       MOV ECX, 4
   ; 5F53:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 5F56:       FF6009           JMP QWORD PTR [RAX+9]
   ; 5F59: L4:   488D1400         LEA RDX, [RAX+RAX]
   ; 5F5D:       4881FA06C48C40   CMP RDX, 1082967046
   ; 5F64:       7C09             JL L5
   ; 5F66:       488B0DD3FEFFFF   MOV RCX, [RIP-301]             ; '((C1))
   ; 5F6D:       EB9B             JMP L0
   ; 5F6F: L5:   488D1400         LEA RDX, [RAX+RAX]
   ; 5F73:       4881FA06C08C40   CMP RDX, 1082966022
   ; 5F7A:       7509             JNE L6
   ; 5F7C:       488B0DC5FEFFFF   MOV RCX, [RIP-315]             ; '((A1))
   ; 5F83:       EB85             JMP L0
   ; 5F85: L6:   48D1E0           SHL RAX, 1
   ; 5F88:       483D06C28C40     CMP RAX, 1082966534
   ; 5F8E:       750C             JNE L7
   ; 5F90:       488B0DB9FEFFFF   MOV RCX, [RIP-327]             ; '((B1))
   ; 5F97:       E96EFFFFFF       JMP L0
   ; 5F9C: L7:   488B15B5FEFFFF   MOV RDX, [RIP-331]             ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100837B74B}>
   ; 5FA3:       488BF9           MOV RDI, RCX
   ; 5FA6:       488B058BFEFFFF   MOV RAX, [RIP-373]             ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 5FAD:       B904000000       MOV ECX, 4
   ; 5FB2:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 5FB5:       FF6009           JMP QWORD PTR [RAX+9]
   ; 5FB8: L8:   483D04684620     CMP RAX, 541485060
   ; 5FBE:       7258             JB L12
   ; 5FC0:       483D03694620     CMP RAX, 541485315
   ; 5FC6:       750C             JNE L9
   ; 5FC8:       488B0D91FEFFFF   MOV RCX, [RIP-367]             ; '((B3))
   ; 5FCF:       E936FFFFFF       JMP L0
   ; 5FD4: L9:   483D036A4620     CMP RAX, 541485571
   ; 5FDA:       750C             JNE L10
   ; 5FDC:       488B0D85FEFFFF   MOV RCX, [RIP-379]             ; '((C3))
   ; 5FE3:       E922FFFFFF       JMP L0
   ; 5FE8: L10:  483D036B4620     CMP RAX, 541485827
   ; 5FEE:       750C             JNE L11
   ; 5FF0:       488B0D79FEFFFF   MOV RCX, [RIP-391]             ; '((D3))
   ; 5FF7:       E90EFFFFFF       JMP L0
   ; 5FFC: L11:  488B1575FEFFFF   MOV RDX, [RIP-395]             ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100837B74B}>
   ; 6003:       488BF9           MOV RDI, RCX
   ; 6006:       488B052BFEFFFF   MOV RAX, [RIP-469]             ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 600D:       B904000000       MOV ECX, 4
   ; 6012:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 6015:       FF6009           JMP QWORD PTR [RAX+9]
   ; 6018: L12:  488D1400         LEA RDX, [RAX+RAX]
   ; 601C:       4881FA06D08C40   CMP RDX, 1082970118
   ; 6023:       7C0C             JL L13
   ; 6025:       488B0D54FEFFFF   MOV RCX, [RIP-428]             ; '((A3))
   ; 602C:       E9D9FEFFFF       JMP L0
   ; 6031: L13:  488D1400         LEA RDX, [RAX+RAX]
   ; 6035:       4881FA06CC8C40   CMP RDX, 1082969094
   ; 603C:       750C             JNE L14
   ; 603E:       488B0D43FEFFFF   MOV RCX, [RIP-445]             ; '((C2))
   ; 6045:       E9C0FEFFFF       JMP L0
   ; 604A: L14:  48D1E0           SHL RAX, 1
   ; 604D:       483D06CE8C40     CMP RAX, 1082969606
   ; 6053:       750C             JNE L15
   ; 6055:       488B0D34FEFFFF   MOV RCX, [RIP-460]             ; '((D2))
   ; 605C:       E9A9FEFFFF       JMP L0
   ; 6061: L15:  488B1530FEFFFF   MOV RDX, [RIP-464]             ; #<FUNCTION (LAMBDA
                                                                 ;                #) {100837B74B}>
   ; 6068:       488BF9           MOV RDI, RCX
   ; 606B:       488B05C6FDFFFF   MOV RAX, [RIP-570]             ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; 6072:       B904000000       MOV ECX, 4
   ; 6077:       FF7508           PUSH QWORD PTR [RBP+8]
   ; 607A:       FF6009           JMP QWORD PTR [RAX+9]
   #+end_example

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (run-standard-object-layout-address-vs-standard-gf
      *standard-object-layout-gf* (make-instance 'd2))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   object
   Evaluation took:
     5.221 seconds of real time
     5.196544 seconds of total run time (5.196544 user, 0.000000 system)
     99.54% CPU
     15,625,516,013 processor cycles
     3,456 bytes consed

   Evaluation took:
     5.154 seconds of real time
     5.135624 seconds of total run time (5.135547 user, 0.000077 system)
     99.65% CPU
     15,426,919,173 processor cycles
     1,216 bytes consed

   #+end_example

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (defparameter *standard-object-layout-gf/few*
       (prepare-standard-object-layout-address-vs-standard-gf (subseq *standard-object-classes* 0 4)))
   #+END_SRC

   #+RESULTS:
   : Assuming argument is an instance: T
   : Assuming argument is an instance: T
   : Assuming argument is an instance: T
   : Assuming argument is an instance: T

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (sb-disassem:disassemble-code-component
       (sb-kernel:funcallable-instance-fun *standard-object-layout-gf/few*))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   ; Size: 208 bytes. Origin: #x1002610A70 (segment 1 of 2)
   ; A70:       .ENTRY (LAMBDA (OBJECT))()                       ; FUNCTION
   ; AA0:       8F4508           POP QWORD PTR [RBP+8]
   ; AA3:       488D65F8         LEA RSP, [RBP-8]
   ; AA7:       488BCA           MOV RCX, RDX
   ; Origin #x1002610AAA (segment 2 of 2)
   ; AAA:       8B4101           MOV EAX, [RCX+1]                ; no-arg-parsing entry point
   ; AAD:       483D04614620     CMP RAX, 541483268
   ; AB3:       734D             JNB L3
   ; AB5:       488D1400         LEA RDX, [RAX+RAX]
   ; AB9:       4881FA06C28C40   CMP RDX, 1082966534
   ; AC0:       7C10             JL L1
   ; AC2:       488B0D6FFFFFFF   MOV RCX, [RIP-145]              ; '((B1))
   ; AC9: L0:   488BD1           MOV RDX, RCX
   ; ACC:       488BE5           MOV RSP, RBP
   ; ACF:       F8               CLC
   ; AD0:       5D               POP RBP
   ; AD1:       C3               RET
   ; AD2: L1:   48D1E0           SHL RAX, 1
   ; AD5:       483D06C08C40     CMP RAX, 1082966022
   ; ADB:       7509             JNE L2
   ; ADD:       488B0D5CFFFFFF   MOV RCX, [RIP-164]              ; '((A1))
   ; AE4:       EBE3             JMP L0
   ; AE6: L2:   488B155BFFFFFF   MOV RDX, [RIP-165]              ; #<FUNCTION (LAMBDA
                                                                 ;                #) {1002222A7B}>
   ; AED:       488BF9           MOV RDI, RCX
   ; AF0:       488B0559FFFFFF   MOV RAX, [RIP-167]              ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; AF7:       B904000000       MOV ECX, 4
   ; AFC:       FF7508           PUSH QWORD PTR [RBP+8]
   ; AFF:       FF6009           JMP QWORD PTR [RAX+9]
   ; B02: L3:   483D03624620     CMP RAX, 541483523
   ; B08:       7509             JNE L4
   ; B0A:       488B0D47FFFFFF   MOV RCX, [RIP-185]              ; '((C1))
   ; B11:       EBB6             JMP L0
   ; B13: L4:   483D03634620     CMP RAX, 541483779
   ; B19:       7509             JNE L5
   ; B1B:       488B0D3EFFFFFF   MOV RCX, [RIP-194]              ; '((D1))
   ; B22:       EBA5             JMP L0
   ; B24: L5:   488B153DFFFFFF   MOV RDX, [RIP-195]              ; #<FUNCTION (LAMBDA
                                                                 ;                #) {1002222A7B}>
   ; B2B:       488BF9           MOV RDI, RCX
   ; B2E:       488B051BFFFFFF   MOV RAX, [RIP-229]              ; #<SB-KERNEL:FDEFN CACHE-MISS>
   ; B35:       B904000000       MOV ECX, 4
   ; B3A:       FF7508           PUSH QWORD PTR [RBP+8]
   ; B3D:       FF6009           JMP QWORD PTR [RAX+9]
   #+end_example

   #+BEGIN_SRC lisp :exports both :results output :package dispatch-experiment
     (run-standard-object-layout-address-vs-standard-gf
      *standard-object-layout-gf/few* #'standard-gf2/few (make-instance 'c1))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   object
   Evaluation took:
     4.222 seconds of real time
     4.173852 seconds of total run time (4.173852 user, 0.000000 system)
     98.86% CPU
     12,634,589,778 processor cycles
     0 bytes consed

   Evaluation took:
     5.806 seconds of real time
     5.740733 seconds of total run time (5.728717 user, 0.012016 system)
     98.88% CPU
     17,379,199,164 processor cycles
     0 bytes consed

   #+end_example

** TODO ~defmethod~ Performance

   + How long does ~defmethod~?

   + How long does a call that causes a miss and discriminating
     function recomputation take?

* Improvement Ideas

** TODO Handle ranges of lowtags, widetags, layout address

** TODO Bit-test-based decision procedure for lowtags (or just in general)
   Important for fixnums which should be tested via ~(zerop (logand
   thing 1))~

** TODO nyef's Remarks
   #+BEGIN_EXAMPLE
     <scymtym> beach: i integrated tag-based dispatch into the decision
               procedure. now it basically wins against PCL for all cases i
               tested. and this is despite two major optimizations still
               missing. example of a generated discriminated dispatch function:
               http://paste.lisp.org/display/355424  [16:43]
     <phoe> scymtym: I'm no specialist but this looks like some heavily optimized
            Lisp  [16:49]
     <scymtym> phoe: i think it doesn't look that optimized. there aren't even any
               declarations. to me, it is a bit astonishing that something this
               simple can be on par with PCL (which has crazy optimization tricks)
                                                                             [16:54]
     <phoe> scymtym: actually, lots of number arithmetics already looks quite
            optimized.  [16:55]
     <beach> scymtym: Great stuff.  [16:58]
     <phoe> but this news is really crazy now that you speak of it
     <phoe> this might only mean that the whole "generic dispatch is slower" issue
            is alleviated  [16:59]
     <beach> scymtym: I think people are more interested in SBCL than in SICL, and
             I think they are more interested in a real benchmark than my
             artificial one.  That's why I think your result is worth a paper.
     <scymtym> a bit too early for that. PCL does a lot more. if anything, it shows
               potential
     <scymtym> phoe: ^
     <phoe> scymtym: roger.  [17:00]
     <scymtym> beach: honestly, i can't imagine this becoming relevant to
               sbcl. making changes, let alone such fundamental ones, in sbcl is
               hard, at least for me. i don't know how dougk does it, he's like a
               machine  [17:02]
     <beach> phoe: I have been saying for a long time that, instead of avoiding
             generic functions, people should try to improve the technique used for
             generic dispatch, and more recently, I have been telling people that
             it will happoen.
     <beach> happen.  [17:03]
     <beach> scymtym: Yeah, you may be right.
     <phoe> beach: I remember you telling this for at least a year.
     <phoe> s/telling/saying/
     <scymtym> beach: a variant of this may still be usable for sicl, though. you
               also have "lowtags" and "stamps" are similar to layout addresses
                                                                             [17:04]
     <scymtym> beach: in fact, if more objects are general instances, the
               lowtag/widetag part would be vastly simpler and faster
     <beach> scymtym: Not sure what you mean.  The technique was designed for SICL.
     <beach> scymtym: Yes, the number of tests in SICL would be much smaller.
                                                                             [17:05]
     <scymtym> beach: it's a bit of a trade-off, i guess. dispatching exclusively
               on lowtag is fast, so having many things not be general instances
               can also be beneficial   [17:07]
     <beach> I am thinking that, for SICL, I will first test whether I have a tag
             for general instances, in which case, I invoke the rest of the chain,
             because that is likely to be the most common case.  [17:08]
     <beach> The rest of the chain is, get the stamp, etc...
     <scymtym> beach: the main complication for sbcl seems to be that there are
               several different ways to extract widetags and layouts. so yeah,
               only having immediates and general instances would simplify that
     <beach> I also have CONSes which don't have a stamp.
     <beach> So if it is not a general instance, I get the stamp a more complicated
             way, namely through the class defined by the tag.  [17:09]
     <scymtym> why not use the tag directly in that case?
     <beach> Sure, yeah, that's probably better.  [17:10]
     <beach> I don't think that case will be common though.
     <beach> I don't see much dispatch on character, number, cons.
     <scymtym> finum and cons come to mind
     <scymtym> *fixnum
     <phoe> (hey, I did that today! dispatching on chars)
     <beach> OK, OK, I get the message. :)  [17:11]
     <phoe> :)
     <phoe> oh wait - you mean the system class CHARACTER?
     <beach> Yes.
     <phoe> sorry - I did EQL-specializing on chars.
     <phoe> So a different story.
     <beach> That's different.
     <phoe> Please continue. :)
     <scymtym> EQL-specializers are interesting  [17:12]
     <scymtym> for many EQL-specializers with symbols, characters or numbers, one
               could binary search the symbol address, char code or numeric value
               respectively  [17:15]
     <phoe> binary-search? how? what do you mean?
     <phoe> I mean - let's think numbers for a moment, for example.  [17:16]
     <beach> scymtym: Not a bad idea.
     <phoe> You need to have a sorted sequence of numbers that you are searching
            for.
     <beach> phoe: Read up on the technique in my paper.  It uses binary search so
             as to make the algorithm logarithmic.
     <phoe> So if you have 20 methods specializing on numbers 1-20, then... ohhh, I
            seee.
     <phoe> You can enumerate all 20 methods in the discriminating function.
     <phoe> And binsearch until you find the proper one.  [17:17]
     <phoe> Which gives you logarithmic complexity.
     <scymtym> the dispatch function is basically an "unrolled" binary search
     <scymtym> yes
     <beach> phoe: It's all in the paper, except only for stamps, not for eql
             specializers.
     <phoe> But this can be used for all elements that are ordered. Number value
            and char code is doable, symbol address as well since it's an integer.
                                                                             [17:18]
     <scymtym> beach: i think PCL does not always invoke the compiler when the call
               history is extended. what i currently do requires recompiling the
               dispatch function whenever the call history changes. do you think
               this would make the system too slow at "warmimg up"?  [17:19]
     <beach> scymtym: I don't think so.  First of all, you can delay updating the
             dispatch function until it is called, as long as you preserve as much
             of the call history as possible, and as long as computing the dispatch
             function does not have to call any generic functions.  [17:20]
     <beach> scymtym: Second, I use a technique call "satiation" that pre-fills the
             call history of some critical generic functions with an artificial
             call history consisting of all combinations of classes in the system
             that will create a hit.  [17:21]
     <beach> http://metamodular.com/satiation.pdf
     <scymtym> beach: i'm not worrying about bootstrapping right now. for
               user-defined generic functions (which will not have a pre-filled
               call history), each call with previously unseen argument types
               requires recompilation of the discriminating function  [17:24]
     <beach> True.
     <scymtym> actually, the call history could be pre-filled to some extent
     <scymtym> but that may be a bad idea  [17:25]
     <nyef`> G'morning all.
     <beach> scymtym: I do it only for MOP-specified functions, to avoid
             metastability problems.
     <nyef`> I see SBCL-specific hacking going on?
     <beach> Hello nyef`.
     <beach> nyef`: Yes, you might be selected to implement this in SBCL. :)
                                                                             [17:26]
     <scymtym> pre-filling based on the defined methods would reduce the "warm up"
               time but would also add cases to the decision procedure which may
               not occur at runtime
     <beach> Yes, correct.
     <scymtym> i think nyef` isn't super fond of PCL :)
     <nyef`> beach: I hope not. I'm almost completely unfamiliar with the PCL code.
     <nyef`> This tag-testing logic seems bizarre, though.  [17:27]
     <nyef`> Umm... And, IIRC, not all backends have layouts at fixed addresses?
                                                                             [17:28]
     <beach> So I recommend against it, other than when not doing it will create
             metastability problems.
     <beach> Oh, sorry!
     <beach> He is also super fond of "fast" though.
     <nyef`> Why use GET-LISP-OBJ-ADDRESS to compare to an integer instead of using
             EQ and a boxed pointer?  [17:29]
     <scymtym> nyef`: i guess using the clos-hash for other backends for work
               almost as well  [17:30]
     <nyef`> Does this pick off fixnums at all?
     <scymtym> nyef`: what is bizzare about the tag testing?
     <nyef`> Right, lose the use of GET-LISP-OBJ-ADDRESS and use an EQ test and
             LOAD-TIME-VALUE to find the layouts.  [17:31]
     <beach> scymtym: Looks like nyef` would be a better co-author than me.  [17:32]
     <scymtym> nyef`: for now, each fixnum argument results in a leaf for the
               corresponding lowtag. i intend to make the decision tree compiler
               smart enough to eventually reduce the fixnum cases to (zerop
               (logtest tag 1))
     <nyef`> There's a reason why you're not "just" trying to use an
             8-or-16-element CASE here, right?  [17:33]
     <scymtym> beach: both of you can be of great help. for different aspects, of
               course
     <nyef`> Right, fully-unrolled binary search?
     <nyef`> I'd also make the argument that using the tag names rather than the
             tag values would be a benefit to readability, and shouldn't cost
             overmuch in terms of compile time.  [17:35]
     <scymtym> the decision tree compiler sometimes generates things like (if (=
               tag a) (if (= tag b) result-1 result-2) result-3), so it's actually
               a hybrid approach
     <scymtym> nyef`: sure, many things can be improved, i just cobbled this
               together in two afternoons to see how beach's technique would
               perform when employed to sbcl  [17:36]
     <scymtym> nyef`: inserting symbolic tag names would be a bit more complicated,
               though. the input to the decision tree compiler are "call history"
               entries of the form #S(ENTRY :LOWTAGS (3) :WIDETAG NIL :LAYOUT
               #<LAYOUT for STANDARD-CLASS {203AD103}> :OUTCOMES <method list>)
               which are created by looking at the argument and taking
               e.g. LOWTAG-OF, LAYOUT-OF of it  [17:39]
     <nyef`> Okay, that's fair.
     <nyef`> And using the fact that OTHER-IMMEDIATE-LOWTAG is two bits wide is
             unlikely to gain you anything...  [17:40]
     <scymtym> why would using CASE be better? would you somehow place the more
               frequently invoked methods at the top?  [17:41]
     <nyef`> No, I'd try to arrange to compile it as a jump table.
     <beach> nyef`: You don't want that.
     <nyef`> Right, destroys branch predictability.
     <scymtym> it would also require finish pkhuong's computed-goto patch  [17:42]
     <scymtym> *finishing
     <beach> nyef`: And a jump table can be huge, unless you do compression, which
             implies more memory accesses.
     <nyef`> At least it's not a computed come-from patch. d-:
     <scymtym> :)
     <nyef`> Again, 8-or-16-element.
     <nyef`> (8 for 32-bit backends, 16 for 64-bit backends.)
     <nyef`> I'd just be using it for the lowtags.
     <scymtym> i have to go now, will read logs later  [17:43]
     <scymtym> beach: nyef`: thanks for your feedback
     <nyef`> scymtym: You're welcome.

     [Sat Sep  9 2017]
     <nyef`> Hrm. Is this "decision tree compiler" relying on the layouts being
             immobile? Because if so, it's going to break when they aren't, at
             which point can we push the layout discrimination to data space rather
             than code space and get the GC to maintain the invariants that enable
             binary search?  [18:17]
     <beach> nyef`: Yes, it does rely on layouts being immobile, as I understand
             it.  [18:22]
     <beach> nyef`: scymtym did that because SBCL does not have the concept of a
             stamp, the way the paper supposes.
     <nyef`> So, that's a yes to the concern, but no answer on the possible
             solution?  [18:32]
     <nyef`> I guess two other possible angles would be to add immobile space to
             cheneygc and to port all of the remaining cheneygc-only backends to
             gencgc.  [18:33]
     <nyef`> ... Alpha (broken anyway because reasons), MIPS (found a Linux kernel
             bug thanks to this one), and HPPA (never completed).  [18:39]
     <beach> Or, you can add stamps to your general heap-allocated instances.
     * beach thinks to himself, "yeah, in your dreams".
     <nyef`> And immobile-space is x86-64-only.
     <nyef`> (Not even 64-bit generally, x86-64 only.)  [18:40]
     <whoman> amd?  [18:42]
     <nyef`> Right, the AMD-defined 64-bit architecture, not the Itanic.
     <whoman> ah~ i lost count  [18:44]
     <nyef`> So, a "stamp"? Basically an immutable (integer) value that corresponds
             to a class or layout?  [18:45]
     <scymtym> nyef`: a version of a class in the sense that redefinition and
               hierarchy changes produce new versions  [19:31]
     <beach> nyef`: What scymtym says.  [19:38]
   #+END_EXAMPLE
